## 数据库

1. 死锁，如何防止死锁
2. 数据库索引
3. 乐观锁、悲观锁
4. 数据库事务四大特性
5. 你说到了密码要加密后存数据库，用什么方法的，哪些好处

## 什么是死锁？

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。

事实上，计算机世界有很多事情需要多线程方式去解决，因为这样才能最大程度上利用资源，才能体现出计算的高效。但是，实际上来说，计算机系统中有很多一次只能由一个进程使用的资源的情况，例如打印机，同时只能有一个进程控制它。在多通道程序设计环境中，若干进程往往要共享这类资源，而且一个进程所需要的资源还很有可能不止一个。因此，就会出现若干进程竞争有限资源，又推进顺序不当，从而构成无限期循环等待的局面。我们称这种状态为死锁。简单一点描述，死锁是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。很显然，如果没有外力的作用，那么死锁涉及到的各个进程都将永远处于封锁状态。

### 死锁发生的原因？

##### A:java 死锁产生的四个必要条件

1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用
2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。
3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。
4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。

##### B:产生原因：

###### 竞争资源引起进程死锁

当系统中供多个进程共享的资源如打印机、公用队列的等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。

###### 可剥夺资源和不可剥夺资源

系统中的资源可以分为两类，一类是可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。例如，优先权高的进程可以剥夺优先权低的进程的处理机。又如，内存区可由存储器管理程序，把一个进程从一个存储区移到另一个存储区，此即剥夺了该进程原来占有的存储区，甚至可将一进程从内存调到外存上，可见，CPU和主存均属于可剥夺性资源。另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。

###### 竞争不可剥夺资源

在系统中所配置的不可剥夺资源，由于它们的数量不能满足诸进程运行的需要，会使进程在运行过程中，因争夺这些资源而陷于僵局。例如，系统中只有一台打印机R1和一台磁带机R2，可供进程P1和P2共享。假定PI已占用了打印机R1，P2已占用了磁带机R2，若P2继续要求打印机R1，P2将阻塞；P1若又要求磁带机，P1也将阻塞。于是，在P1和P2之间就形成了僵局，两个进程都在等待对方释放自己所需要的资源，但是它们又都因不能继续获得自己所需要的资源而不能继续推进，从而也不能释放自己所占有的资源，以致进入死锁状态。

###### 竞争临时资源

上面所说的打印机资源属于可顺序重复使用型资源，称为永久资源。还有一种所谓的临时资源，这是指由一个进程产生，被另一个进程使用，短时间后便无用的资源，故也称为消耗性资源，如硬件中断、信号、消息、缓冲区内的消息等，它也可能引起死锁。例如，SI，S2，S3是临时性资源，进程P1产生消息S1，又要求从P3接收消息S3；进程P3产生消息S3，又要求从进程P2处接收消息S2；进程P2产生消息S2，又要求从P1处接收产生的消息S1。如果消息通信按如下顺序进行：
P1: ···Relese（S1）；Request（S3）； ···
P2: ···Relese（S2）；Request（S1）； ···
P3: ···Relese（S3）；Request（S2）； ···
并不可能发生死锁。但若改成下述的运行顺序：
P1: ···Request（S3）；Relese（S1）；···
P2: ···Request（S1）；Relese（S2）； ···
P3: ···Request（S2）；Relese（S3）； ···
则可能发生死锁。

进程推进顺序不当引起死锁
由于进程在运行中具有异步性特征，这可能使P1和P2两个进程按下述两种顺序向前推进。

进程推进顺序合法
当进程P1和P2并发执行时，如果按照下述顺序推进：P1：Request（R1）； P1：Request（R2）； P1: Relese（R1）；P1: Relese（R2）； P2：Request（R2）； P2：Request（R1）； P2: Relese（R2）；P2: Relese（R1）；这两个进程便可顺利完成，这种不会引起进程死锁的推进顺序是合法的。

进程推进顺序非法
若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁。

### 如何避免（预防）和解决死锁？

#### A：死锁预防

打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。

打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。

打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。

打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。 [3]

①允许目的节点将不完整的报文递交给目的端系统；
②一个不能完整重装的报文能被检测出来，并要求发送该报文的源端系统重新传送；
③为每个节点配备一个后备缓冲空间，用以暂存不完整的报文。

①、②两种方法不能很满意地解决重装死锁，因为它们使端系统中的协议复杂化了。一般的设计中，网络层应该对端系统透明，也即端系统不该考虑诸如报文拆、装之类的事。③方法虽然不涉及端系统,但使每个节点增加了开销。

##### 有序资源分配法

这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。系统要求申请进程：
1、对它所必须使用的而且属于同一类的所有资源，必须一次申请完；
2、在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2； 进程PB，使用资源的顺序是R2，R1；若采用动态分配有可能形成环路条件，造成死锁。
采用有序资源分配法：R1的编号为1，R2的编号为2；
PA：申请次序应是：R1，R2
PB：申请次序应是：R1，R2
这样就破坏了环路条件，避免了死锁的发生

##### 银行家算法

程序实现思路银行家算法顾名思义是来源于银行的借贷业务，一定数量的本金要应多个客户的借贷周转，为了防止银行家资金无法周转而倒闭，对每一笔贷款，必须考察其是否能限期归还。在操作系统中研究资源分配策略时也有类似问题，系统中有限的资源要供多个进程使用，必须保证得到的资源的进程能在有限的时间内归还资源，以供其他进程使用资源。如果资源分配不得到就会发生进程循环等待资源，则进程都无法继续执行下去的死锁现象。
把一个进程需要和已占有资源的情况记录在进程控制中，假定进程控制块PCB其中“状态”有就绪态、等待态和完成态。当进程在处于等待态时，表示系统不能满足该进程当前的资源申请。“资源需求总量”表示进程在整个执行过程中总共要申请的资源量。显然，每个进程的资源需求总量不能超过系统拥有的资源总数， 银行算法进行资源分配可以避免死锁。

#### B:解决方法

##### 死锁预防

这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。

##### 死锁避免

系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的动态策略。

##### 死锁检测和解除

先检测：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。检测方法包括定时检测、效率低时检测、进程等待时检测等。
然后解除死锁：采取适当措施，从系统中将已发生的死锁清除掉。
这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。

如果我们在死锁检查时发现了死锁情况，那么就要努力消除死锁，使系统从死锁状态中恢复过来。消除死锁的几种方式：

最简单、最常用的方法就是进行**系统的重新启动**，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程；

**撤消进程，剥夺资源。**终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素；

**进程回退策略，**即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的。

## 乐观锁、悲观锁

乐观锁比较适用于读多写少的情况(多读场景)，悲观锁比较适用于写多读少的情况(多写场景)。

### 二、悲观锁(Pessimistic Lock)

1️⃣理解
 当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。

悲观锁，具有强烈的独占和排他特性。它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改持保守态度。因此，在整个数据处理过程中，将数据处于锁定状态。[悲观锁的实现，往往依靠数据库提供的锁机制(也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据)](https://www.jianshu.com/p/c8f997e7f75c)。

![img](https:////upload-images.jianshu.io/upload_images/7038163-ea0875b10d5864c7.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1080/format/webp)



之所以叫做悲观锁，是因为这是一种对数据的修改持有悲观态度的并发控制方式。总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，因此需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起。悲观锁的实现：

1. 传统的关系型数据库使用这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。
2. Java 里面的同步 [synchronized](https://www.jianshu.com/p/c8f997e7f75c) 关键字的实现。

2️⃣悲观锁主要分为[共享锁和排他锁](https://www.jianshu.com/p/b4731a7d255a)：

- 共享锁【shared locks】又称为读锁，简称 S 锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。
- 排他锁【exclusive locks】又称为写锁，简称 X 锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁。获取排他锁的事务可以对数据行读取和修改。

3️⃣说明
 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。

# 三、乐观锁(Optimistic Locking)

1️⃣理解
 乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量。

![img](https:////upload-images.jianshu.io/upload_images/7038163-dea06d00a74071fb.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

乐观锁采取了更加宽松的加锁机制。也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。乐观锁的实现：

1. CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。
2. 版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。

2️⃣说明
 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。

## 数据库索引

索引是定义在table基础之上，有助于无需检查所有记录而快速定位所需记录的一种**辅助存储结构**，由一系列存储在磁盘上的索引项组成，每一种索引项由索引字段和行指针构成。

### 索引的好处？

1. 通过创建索引,可以在查询的过程中,提高系统的性能；
2. 通过创建唯一性索引,可以保证数据库表中每一行数据的唯一性；
3. 在使用分组和排序子句进行数据检索时,可以减少查询中分组和排序的时间；

### 索引的坏处？

1. 创建索引和维护索引要耗费时间,而且时间随着数据量的增加而增大；
2. 索引需要占用物理空间,如果要建立聚簇索引,所需要的空间会更大；
3. 在对表中的数据进行增加删除和修改时需要耗费较多的时间,因为索引也要动态地维护；

### 什么是稠密索引和稀疏索引？

- 稠密索引：对于主文件中每一个记录都对应一个索引项；
  - 候选键属性的稠密索引：先查索引，然后再依据索引读主文件；
  - 非候选键属性的稠密索引：
    - 主文件按索引字段排序，索引文件中的索引字段值无重复；
    - 主文件索引字段未排序，但索引文件中的索引字段值是有重复的；
    - 主文件索引字段未排序且索引文件中的索引字段值无重复，这时可以引入指针桶来处理；
- 稀疏索引：对于主文件中部分记录有索引项和它对应（要求主文件必须是按对应索引字段属性排序存储）；

### 什么是主索引和辅助索引？

- 主索引：对每个存储块有一个索引项，每个存储块的第一个记录叫锚，通常建立在有序文件的基于**主码**的排序字段上，属于稀疏索引。
- 辅助索引：是定义在主文件的任一或多个非排序字段上的辅助存储结构，属于稠密索引。

   补充：一个主文件可以有一个主索引，但可以有多个辅助索引。

### 什么是聚簇索引和非聚簇索引？

- 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据，主文件按照对应字段排序存储，索引文件无重复排序存储。
- 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，主文件并没有按照对应字段排序存储，索引文件有重复排序存储。

![img](https://img-blog.csdnimg.cn/20200513165654656.png)

![img](https://img-blog.csdnimg.cn/20200513165710753.png)

补充：

1. 如果主文件的某一排序字段不是主码，则该字段上每个记录取值便不唯一，此时该字段被称为**聚簇字段**，聚簇索引通常是定义在聚簇字段上。
2. 聚簇索引通常是对聚簇字段上每一个不同值有一个索引项。
3. 一个主文件只能有一个聚簇索引文件，但可以有多个非聚簇索引文件。
4. **主索引通常是聚簇索引，辅助索引通常是非聚簇索引**。
5. 主索引/聚簇索引是能够决定记录存储位置的索引，而非聚簇索引则只能用于查询，不能改变物理位置。

### 为什么主键通常建议使用自增id？

答：**聚簇索引的数据的物理存放顺序与索引顺序是一致的**，即：**只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的**。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页。

### mysql中聚簇索引的设定？

答：聚簇索引**默认是主键**，如果表中没有定义主键，InnoDB 会选择一个**唯一的非空索引**代替。如果没有这样的索引，InnoDB 会**隐式定义一个主键**来作为聚簇索引。

### 什么是倒排索引和正排索引？

- 倒排索引：一个词汇包含在哪些文档中，倒排索引主要由两个部分组成：“单词词典”和“倒排文件”，应用于搜索引擎。
- 正排索引：一个文档包含了哪些词汇。

其他结构的索引？

- 多级索引：对索引再建立索引，如B树/B+树等；
- 多属性索引：索引字段由多个属性组合一起形成的索引；
- 散列索引：使用散列技术组织的索引；
- 网络索引：使用多索引字段进行交叉联合定位与检索；

------

### B+树

B+树是通过二叉查找树，再由平衡二叉树，B树演化而来。

二叉排序树：**左子树的键值总是小于根的键值，右子树的键值总是大于根的键值，**因此可以通过中序遍历得到键值的排序输出。

![img](https://img-blog.csdnimg.cn/20200513201849849.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6eWFpd2w=,size_16,color_FFFFFF,t_70)

平衡二叉树：**首先复合二叉查找树的定义，其次必须满足任何节点的两个子树的高度最大差为1.**(平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。)

m阶B-树：树中每个结点至多m棵子树、非叶子结点的根结点至少有两棵子树、除根结点外的非叶子结点至少有m/2棵子树、所有的叶子结点出现在同一层，并且不带信息，通常称为失败结点、树中每个结点的关键字有序，且关键字的左子树中的关键字均小于它，右子树均大于它。（单个节点可以存储多个键值和数据的平衡树）

![img](https://img-blog.csdnimg.cn/20200513202402596.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6eWFpd2w=,size_16,color_FFFFFF,t_70)

m阶B+树：与B-树差异在于有n棵子树的结点中含有n个关键字、所有的叶子节点包含了全部关键字的信息，以及指向这些关键字记录的指针、所有的非终端结点可以看成是索引部分，结点中仅含有其子树中最大的关键字。

![img](https://img-blog.csdnimg.cn/20200513202842124.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6eWFpd2w=,size_16,color_FFFFFF,t_70)

B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，使得范围查找，排序查找，分组查找以及去重查找变得异常简单。



## 数据库四大特性

如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：

1、原子性（Atomicity）
　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

2、一致性（Consistency）
　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

3、隔离性（Isolation）
　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

4、持久性（Durability）
　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，
即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

## 对称加密算法

对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。

### 特点

- 优点：算法公开、计算量小、加密速度快、加密效率高。
- 缺点：在[数据](http://www.fly63.com/)传送前，发送方和接收方必须商定好密钥，然后双方保存好密钥。如果一方的密钥被泄露，那么加密信息也就不安全了
- 使用场景：本地[数据](http://www.fly63.com/)加密、https 通信、网络传输等

### AES

AES：高级加密标准(Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。

![img](http://api.fly63.com/vue_blog/public/Uploads/20200315/5e6e300359fcc.jpg)

密钥：用来加密明文的密码。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取[数据](http://www.fly63.com/)。

在项目中需要用到 AES 加密时，可以使用开源的 [js](http://www.fly63.com/tag/js) 库：[crypto-js](https://github.com/brix/crypto-js)

```
var Cryptojs = require('crypto-js');

var data = { id: 1, text: 'Hello World' };

// 加密生成密文
var ciphertext = Cryptojs.AES.encrypt(jsON.stringify(data), 'secret_key_123').toString();

// 解密得到明文
var bytes = Cryptojs.AES.decrypt(ciphertext, 'secret_key_123');
var decryptedData = jsON.parse(bytes.toString(Cryptojs.enc.Utf8));
```

 

## 非对称加密算法

非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对[数据](http://www.fly63.com/)进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

### 特点

- 优点：非对称加密与对称加密相比其安全性更好
- 缺点：加密和解密花费时间长、速度慢，只适合对少量[数据](http://www.fly63.com/)进行加密。
- 使用场景：https 会话前期、CA 数字证书、信息加密、登录认证等

### RSA

RSA 加密算法是非对称加密算法最常见的一种。RSA 是 1977 年由 Ron Rivest、Adi Shamir 和 Leonard Adleman 一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。

![img](http://api.fly63.com/vue_blog/public/Uploads/20200315/5e6e300874882.jpg)

在项目中需要用到 RSA 加密时，可以使用开源的 [js](http://www.fly63.com/tag/js) 库：[jsencrypt](https://github.com/travist/jsencrypt)

```
// 使用公钥加密
var publicKey = 'public_key_123';
var encrypt = new jsEncrypt();
encrypt.setPublicKey(publicKey);
var encrypted = encrypt.encrypt('Hello World');

// 使用私钥解密
var privateKey = 'private_key_123';
var decrypt = new JSEncrypt();
decrypt.setPrivateKey(privateKey);
var uncrypted = decrypt.decrypt(encrypted);
```

 

## Hash 算法

Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。

简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的[函数](http://www.fly63.com/tag/函数)。

### 特点

- 优点：不可逆、易计算、特征化
- 缺点：可能存在散列冲突
- 使用场景：文件或字符串一致性校验、数字签名、鉴权协议

### MD5

MD5 是比较常见的 Hash 算法，对于 MD5 而言，有两个特性是很重要的，第一：明文[数据](http://www.fly63.com/)经过散列以后的值是定长的；第二：是任意一段明文[数据](http://www.fly63.com/)，经过散列以后，其结果必须永远是不变的。前者的意思是可能存在有两段明文散列以后得到相同的结果，后者的意思是如果我们散列特定的数据，得到的结果一定是相同的。

比如在登录时将密码进行 md5 加密再传输给服务器，服务器中的密码也是用 md5 加密后存储的，那么只要验证加密后的密文是否一致则可。

在项目中需要用到 MD5 加密时，可以使用开源的 js 库：[JavaScript-MD5](https://github.com/blueimp/JavaScript-MD5)

```
var hash = md5('Hello World');
// b10a8db164e0754105b7a99be72e3fe5
```

 

## Base64 编码

Base64 编码只是一种编码格式并不是加密算法，它可用于在 HTTP 环境下传递较长的标识信息。

### 特点

- 可以将任意的二进制数据进行 Base64 编码
- 数据加密之后，数据量会变大，变大 1/3 左右
- 编码后有个非常显著的特点，末尾有个=号
- 可进行反向解码
- Base64 编码具有不可读性

现代[浏览器](http://www.fly63.com/tag/浏览器)都提供了 Base64 编码、解码方法，btoa() 和 atob()

```
var enc = window.btoa('Hello World');
// SGVsbG8gV29ybGQ=

var str = window.atob(enc);
// Hello World
```

 

## 总结

在业务 http 请求中，AES 的密钥在[前端](http://www.fly63.com/)随机生成，从服务器获取 RSA 的公钥，对 AES 的密钥进行非对称加密，把加密后的密钥在请求头中传给服务器，用 AES 对 body 进行加密。服务器收到请求头中的加密后的密钥，用 RSA 的密钥进行解密，得到明文的 AES 密钥，即可对 body 进行解密。md5 有校验字符串一致性的特性，为避免请求被拦截后篡改 body，可在发请求时，将 body 字符串进行一个 md5 加密后在请求头传输，服务器收到请求后，解密 body 后再 md5 与请求头的进行校验，可验证是否请求被篡改。